#' @title copy_detect
#'
#' @description This function separates gene copies from a single subset.
#'
#' @param filename A fasta file containing short reads from a single subset generated by "subset_downsize".
#'
#' @param copy_number An interger (e.g. 2,3, or 4) giving the expected number of gene copies in the input file.
#'
#' @param lower_threshold A decimal (range: 0.01-0.99) giving the OTU identity cutoff for divisive heirarchical clustering analyses. Default 0.4.
#'
#' @param kmer An integer giving the k-mer size used to generate the input matrix for k-means clustering. Default 5.
#'
#' @return A fasta alignment of the gene copies found in the input dataset.
#'
#' @importFrom seqinr read.fasta write.fasta
#'
#' @importFrom stringr str_sort
#'
#' @importFrom kmer otu
#'
#' @importFrom Biostrings readDNAStringSet
#'
#' @importFrom ape as.character.DNAbin read.FASTA
#'
#' @importFrom DECIPHER ConsensusSequence
#'
#' @importFrom beepr beep
#'
#' @export copy_detect
#'

copy_detect<-function(filename,copy_number,lower_threshold=0.4,kmer=5)
{
  sink("log.txt", append=FALSE, split=TRUE) # begin to record log
  error_log_function <- function() {
    cat(geterrmessage(), file="Error_log.txt", append=T)
  }

  if (copy_number<=1) stop ("The expected copy number must be a number larger than one!")

    Subset <- ape::as.character.DNAbin(ape::read.FASTA(file=filename, type = "DNA"))
    cat(paste0("Clustering analyses for ", filename,"\n"))

    filename_short <- gsub("[:.:].*","", filename) # remove file extensions, e.g. ".fasta", ".txt"

    # try different threshold values for OTU to find the "copy_number" major clusters for each subset
    for (i in seq(lower_threshold,0.99, by = 0.01)) {
      Subset_OTU <- kmer::otu(Subset, k = kmer, threshold = i, method = "central", nstart = 20)
      cat(paste0("threshold = ",i),"\n")
      cat(unique(Subset_OTU),"\n")
      if (length(unique(Subset_OTU))>=copy_number) {break}
    }
    reads_each_cluster <- sapply(unique(Subset_OTU), function(x) length(which(Subset_OTU==x)))

    cat(paste0("Best threshold = ",i),"\n")
    cat(unique(Subset_OTU),"\n")
    cat("Number of reads in each cluster\n")
    cat(reads_each_cluster,"\n")

    for (j in (1:copy_number)) {
      seqinr::write.fasta(sequences = Subset[which(Subset_OTU==unique(Subset_OTU)[which(reads_each_cluster==sort(reads_each_cluster)[length(unique(Subset_OTU))-j+1])])],
                names = labels(Subset[which(Subset_OTU==unique(Subset_OTU)[which(reads_each_cluster==sort(reads_each_cluster)[length(unique(Subset_OTU))-j+1])])]),
                file.out = paste0(filename_short,"_cluster_",j,".fasta"))
      cat(paste0("Number of reads in picked cluster ",j, " = ", length(Subset[which(Subset_OTU==unique(Subset_OTU)[which(reads_each_cluster==sort(reads_each_cluster)[length(unique(Subset_OTU))-j+1])])]),"\n"))

    # calcuate the consensus sequence for the clusters of the subset
    seqinr::write.fasta(sequences = as.character(DECIPHER::ConsensusSequence(Biostrings::readDNAStringSet(paste0(filename_short,"_cluster_",j,".fasta"),format="fasta",nrec=-1L, skip=0L),threshold = 0.4,
    ambiguity = TRUE, noConsensusChar = "N")[1]),names = paste0(filename_short,"_cluster_",j,"_consensus"), file.out = paste0(filename_short,"_cluster_",j,"_consensus.fasta"))
    }

    # put together all the consensus sequences into one file
    Consensus_list <- stringr::str_sort(list.files(pattern="_consensus.fasta"), numeric = TRUE)
    All_consensus <- lapply(1:length(Consensus_list), function (x) seqinr::read.fasta(file = Consensus_list[x], seqtype = "DNA",
                                                                              as.string = TRUE,forceDNAtolower = FALSE,set.attributes = FALSE, whole.header = TRUE))
    seqinr::write.fasta(sequences=All_consensus, names=Consensus_list, file.out=paste0(filename_short,"_consensus_list.fasta"))
    cat("Run finished!\n")
    beepr::beep(sound = 1, expr = NULL) # make a sound when run finishes
    options("error" = error_log_function)
    sink() # turn off log
}


